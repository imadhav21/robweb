<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="/bcss/bootstrap.min.css">
    <link rel="stylesheet" href="/p2.css">
    <link rel="shortcut icon" type="image/jpg" href="/Pictures/book.png"/>

    <title>Rob 102</title>
</head>
<body>
    <nav class ="navbar navbar-expand-md navbar-dark fixed-top nav-dark" id="navbarnavbar">

        <a href="#" class="text-white text-center lead"><p class = 'h3 font-weight-light'>Robotics 102</p></a>

        <button class="navbar-toggler" data-toggle = "collapse" data-target="#menu">
            <span class= "navbar-toggler-icon"></span>
        </button>

        <div class="text-white collapse navbar-collapse" id="menu">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item mx-3">
                    <a href="/p2.html" class="nav-link h4 font-weight-light">Project 2</a>
                </li>
                <li class="nav-item mx-3">
                    <a href="#" class="nav-link h4 font-weight-light">Project 3</a>
                </li>
            </ul>
        </div>
    </nav>

    <div class="container-fluid py-5 cb">
        <div class="display-4 text-center text-white pt-5">Project 2 - Potential Fielding</div>
    </div>
    
    
    <div class="media_container">
        <h3 class="simulation_title">Robot Simulations</h3>
        <p class="simulation_description">Below are some examples of the test of the robot's potential fielding in the Web Application.</p>
    
        <div class="video_container">
            <div class="video_item">
                <h4 class="video_item_title">Using the Distance Transform Slow Algorithm #1</h4>
                <iframe class="video_item_iframe" src="https://www.youtube.com/embed/hC7yVYOTtgs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
            <div class="video_item">
                <h4 class="video_item_title">Using the Distance Transform Manhattan Algorithm #1</h4>
                <iframe class="video_item_iframe" src="https://www.youtube.com/embed/R996QZLY_bE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
            <div class="video_item">
                <h4 class="video_item_title">Using the Distance Transform Slow Algorithm #2</h4>
                <iframe class="video_item_iframe" src="https://www.youtube.com/embed/QsqlKc_d5mE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
            <div class="video_item">
                <h4 class="video_item_title">Using the Distance Transform Manhattan Algorithm #2</h4>
                <iframe class="video_item_iframe" src="https://www.youtube.com/embed/xVCFKs8pxY4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
        </div>
    
        <h3>Now, here are some examples of the actual robot in action.</h3>
    
        <div class="video_container">
            <div class="video_item">
                <h4 class="video_item_title">Robot going in a relatively straight line</h4>
                <iframe class="video_item_iframe" src="https://www.youtube.com/embed/jyxcsQsIFgs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            </div>
            <div class="video_item">
                <h4 class="video_item_title">Robot going in a relatively straight line</h4>
                <img src="/Pictures/pitch.png" width = 50% alt="">
            </div>
        </div>
    </div>

    <div class="content_container">
    
        <div class="content_item">
            <h2>                 
                Understanding What is Going On                        
            </h2>
            <p>
                There were two main methods of the distance transform used, namely the distanceTransformSlow() and distanceTransformManhattan(). 
                
                <br><br> For the slow(), we first looped through each cell in the 
                graph. And for each cell in the graph, we looped through all the cells again in order to find the minimum distance of the orginal cell to an occupied cell. The benefit of this is that it found the direct distance to an occupied cell from a cell. 
                However, this is a very tedious approach as this 
                operates in N^2 time, meaning as the graph gets larger and larger, it will take longer and longer to complete. 
                
                <br><br>However, the Manhattan() solved this issue. While it did not find the direct distance, but instread found the block distance (going up, down, left, right, no diagonal) for each cell to every occupied cell. 
                For the Manhattan(), we did an implementation of a forwards pass and then a backwards pass. First, the graph was initialized
                meaning if a cell was occupied, it would set the obstacle distance to 0, and if it was not occupied, it would set it to a very high value. The forward pass would then get the minimum value of itself, its top neighbor + 1, or its left neighbor + 1.
                This is so that it basically increments by 1 from an occupied cell. The same concept is for the backwards pass, whicn starts at the end of the graph and gets the min of itself, the right neightbor + 1, or the left neighbor + 1

                <br><br> Aside from this, two other vectors were involved, namely the createAttractive() and createRepulsive(). These functions do what the name suggestly, namely Attractive() loops through each cell and find the euclidian distance to the goal cell.
                This makes the robot want to follow the low values and avoid the high values. However, the Repulsive() comes into picture to help avoid obstacles. An exponential is currently being used that basically helps to squash negative values, and helps normalize
                it in a sense. The equation used was exp(-C * obstacle_dists[i]).

                <br><br>Once this is done, the createPotential() is next, where for each cell in the graph, the createAttractive() and createRepulsive() were combined together. 
            </p>
        </div>
        <div class="content_item">
            <h2>                 
                The strengths and weaknesses of this implementation                        
            </h2>
            <p>
                One of the strengths of the potential field application is that it is able to avoid obstacles well in theory, albeit at a low level. The repulsive field helps to repel the robot away from the walls so it can get to the goal.
                <br><br>
                However, there are quite a bit of problems with this application. Namely, it cannot do anything complex, like a maze. Even if the goal is right behind an obstacle like a wall, the robot will drive to the wall and it will think it has reached the goal.
                That was a big problem while testing it out, that it would basically get stuck behind a wall of some sort and think it reached the goal.
                <br><br>
                One way I could think to improve this algorithm is instead of having this solely rely on the potential field and the robot going toward the low values, there could be a check that asks if the robot has reached its goal destination
                If it has not reached its goal, then it realizes it is in a local minimum, and a new path must be sought out. Or another way could be having the robot calculate multiple paths to the goal, and seeing which one actually makes sense and avoid going into the 
                high value area, meaning closer to obsticles, as best as possible.
            </p>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
         
    <script>
       $(function() {var header = $(".navbar");
  
        $(window).scroll(function() {    
            var scroll = $(window).scrollTop();
            if (scroll >= 50) {
                header.addClass("nav-dark");
            } else {
                header.removeClass("nav-dark");
            }
        });
    
         });

    </script>

</body>
</html>